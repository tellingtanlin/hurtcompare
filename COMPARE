Option Explicit

'========================
' 入口：一键跑完（怪打人 + 人打怪）并回填 16-22
' 输出过程写到 NM_OUT，避免“对比表格”反复 1004
'========================
Public Sub Compare_NewModel_RunAll()
    Const SH_COMPARE As String = "对比表格"
    Const SH_PERSON  As String = "人物枪支属性"
    Const SH_OUT     As String = "NM_OUT"

    Dim wsC As Worksheet, wsP As Worksheet, wsO As Worksheet
    If Not SheetExists(SH_COMPARE) Then MsgBox "缺少Sheet【" & SH_COMPARE & "】": Exit Sub
    If Not SheetExists(SH_PERSON) Then MsgBox "缺少Sheet【" & SH_PERSON & "】": Exit Sub
    Set wsC = ThisWorkbook.Worksheets(SH_COMPARE)
    Set wsP = ThisWorkbook.Worksheets(SH_PERSON)
    Set wsO = GetOrCreateSheet(SH_OUT)

    Application.ScreenUpdating = False
    Application.EnableEvents = False
    Application.Calculation = xlCalculationManual

    On Error GoTo FIN

    '1) 读护甲初始耐久（人物枪支属性：护甲/初始耐久）
    Dim armorDur(1 To 5) As Double
    If Not LoadArmorDurability_FromPersonSheet(wsP, armorDur) Then
        MsgBox "未找到【护甲/初始耐久】表（人物枪支属性里，表头要包含：护甲 | 初始耐久，下面 5 行对应 1~5 级）", vbExclamation
        GoTo FIN
    End If

    '2) 定位并读取 O/P/Q 分层表（差值下限(闭) / 差值上限(开) / 对肉伤的影响）
    Dim tierHdr As Long, tierFirst As Long, tierLast As Long
    If Not DetectTierTable_OPQ(wsC, tierHdr, tierFirst, tierLast) Then
        MsgBox "未找到 O/P/Q 分层表（表头需包含：差值下限(闭)、差值上限(开)、对肉伤的影响）", vbExclamation
        GoTo FIN
    End If

    Dim tLow() As Double, tHigh() As Double, tRate() As Double, tCnt As Long
    If Not LoadTierArrays(wsC, tierFirst, tierLast, tLow, tHigh, tRate, tCnt) Then
        MsgBox "O/P/Q 分层表数据无效（需要连续数字区间 + Q 为百分比或小数）", vbExclamation
        GoTo FIN
    End If

    '3) 从“对比表格”读取怪物属性（你图里的 A~I：怪物、等级、气血、护甲等级、肉伤、穿透、甲伤）
    Dim monRow1 As Long, monRowN As Long
    If Not DetectMonsterTable(wsC, monRow1, monRowN) Then
        MsgBox "未找到怪物属性表（需包含列：怪物/等级/气血/护甲等级/肉伤/穿透/甲伤）", vbExclamation
        GoTo FIN
    End If

    '4) 从“人物枪支属性”读取枪表/子弹表（只用于 人打怪 汇总；怪打人不需要）
    Dim gunOK As Boolean, bulletOK As Boolean
    Dim gunMap As Object, bulletMap As Object
    Set gunMap = CreateObject("Scripting.Dictionary")
    Set bulletMap = CreateObject("Scripting.Dictionary")
    gunOK = LoadGunTable(wsP, gunMap)
    bulletOK = LoadBulletTable(wsP, bulletMap)
    '如果人打怪你暂时还没要跑全，也可以允许 gunOK/bulletOK 为 False；这里只提示不退出
    If (Not gunOK) Or (Not bulletOK) Then
        '不退出：先保证怪打人可跑
    End If

    '5) 清空输出表并写演算过程（NM_OUT）
    wsO.Cells.Clear

    Dim outR As Long: outR = 1
    WriteTitle wsO, outR, "新模型逐步演算（输出在 NM_OUT；对比表格只回填 16-22）": outR = outR + 2

    'A) 怪打人：分别 mLv=1..5 输出逐步
    Dim mLv As Long
    For mLv = 1 To 5
        outR = WriteBlock_MonsterHitsPerson_New(wsO, outR, wsC, monRow1, monRowN, mLv, armorDur, tLow, tHigh, tRate, tCnt) + 2
    Next mLv

    'B) 人打怪：只做“期望次数汇总回填 16-22”，逐步过程如需也可以输出（这里先不输出大块，避免卡）
    If gunOK And bulletOK Then
        WriteSummary_PersonHitsMonster wsC, monRow1, monRowN, gunMap, bulletMap, tLow, tHigh, tRate, tCnt
    End If

    'C) 怪打人：汇总回填 16-22（把怪打人期望次数写到对应区域——你原先 16-22 里那块“怪打人”）
    WriteSummary_MonsterHitsPerson wsC, monRow1, monRowN, armorDur, tLow, tHigh, tRate, tCnt

    Application.Calculation = xlCalculationAutomatic
    wsO.Calculate
    wsC.Calculate

FIN:
    Application.Calculation = xlCalculationAutomatic
    Application.EnableEvents = True
    Application.ScreenUpdating = True
    If Application.Calculation <> xlCalculationAutomatic Then Application.Calculation = xlCalculationAutomatic
End Sub

'=========================================================
' 写标题（只在 NM_OUT 写，避免对比表格 1004）
'=========================================================
Private Sub WriteTitle(ByVal ws As Worksheet, ByVal r As Long, ByVal s As String)
    ws.Cells(r, 1).Value2 = s
    ws.Cells(r, 1).Font.Bold = True
End Sub

'=========================================================
' Sheet 工具
'=========================================================
Private Function SheetExists(ByVal name As String) As Boolean
    On Error GoTo EH
    Dim ws As Worksheet
    Set ws = ThisWorkbook.Worksheets(name)
    SheetExists = True
    Exit Function
EH:
    SheetExists = False
End Function

Private Function GetOrCreateSheet(ByVal name As String) As Worksheet
    If SheetExists(name) Then
        Set GetOrCreateSheet = ThisWorkbook.Worksheets(name)
    Else
        Set GetOrCreateSheet = ThisWorkbook.Worksheets.Add(After:=ThisWorkbook.Worksheets(ThisWorkbook.Worksheets.Count))
        GetOrCreateSheet.name = name
    End If
End Function

'=========================================================
' 逐步演算：写法B（defPerf/pProb不变）
' 唯一变化：穿透肉伤系数 pb = OPQ 分层查得（delta=pen-armorLv*10）
'
' 关键点：pb 用兼容写法 + MATCH(1,(delta>=O)*(delta<P),0) 精确命中，不要求 O 升序
'=========================================================
Private Function LoadArmorDurability_FromPersonSheet(ByVal ws As Worksheet, ByRef armorDur() As Double) As Boolean
    LoadArmorDurability_FromPersonSheet = False

    Dim ur As Range: Set ur = ws.UsedRange
    Dim r As Long, c As Long

    For r = 1 To ur.Rows.Count
        For c = 1 To ur.Columns.Count - 1
            If Trim$(CStr(ur.Cells(r, c).Value2)) = "护甲" _
               And Trim$(CStr(ur.Cells(r, c + 1).Value2)) = "初始耐久" Then

                Dim hdr As Long: hdr = ur.Row + r - 1
                Dim colDur As Long: colDur = ur.Column + c '右侧“初始耐久”列（绝对列号）

                Dim i As Long
                For i = 1 To 5
                    armorDur(i) = CDbl(Nz(ws.Cells(hdr + i, colDur).Value2, 0))
                Next i

        'defPerf
        Dim defPerf As String
        defPerf = "(121-5000/(45+((" & prevA & ")/225*100)*2))*(" & armorLv & "*10)/100"

        'pProb（保持旧）
        Dim pProb As String
        pProb = "IF(" & defPerf & "<" & pen & _
                ls & pen & "/(0.9*" & defPerf & "-" & pen & ")+100" & _
                ls & "IF(" & defPerf & "-" & pen & "<15" & _
                     ls & "0.4*POWER(" & defPerf & "-" & pen & "-15" & ls & "2)" & _
                     ls & "0)" & _
                ")/100"

        'delta = pen - armorLv*10
        Dim deltaExpr As String
        deltaExpr = "(" & pen & "-" & armorLv & "*10)"

        'pb：精确命中区间（low<=delta<high）
        '如果没命中，默认 1
        Dim pbExpr As String
        pbExpr = "IFERROR(INDEX(" & addrRate & ls & _
                 "MATCH(1" & ls & "(" & deltaExpr & ">=" & addrLow & ")*(" & deltaExpr & "<" & addrHigh & ")" & ls & "0))" & _
                 ls & "1)"

        '穿透/未穿透肉伤（写法B）
        Dim penF As String, npF As String
        penF = "MAX(1" & ls & "CEILING((" & pbExpr & ")*" & flesh & ls & "1))"
        npF = "MAX(1" & ls & "CEILING(0.04*" & flesh & ls & "1))"

        '期望肉伤
        Dim expF As String
        expF = "IF(" & prevA & "=0" & ls & flesh & ls & _
               "(" & pProb & ")*" & penF & "+(1-(" & pProb & "))*" & npF & ")"

        SetCellFormulaCompat ws.Cells(r, cDef), "=IFERROR(" & defPerf & ls & "0)"
        SetCellFormulaCompat ws.Cells(r, cP), "=IFERROR(" & pProb & ls & "0)"
        SetCellFormulaCompat ws.Cells(r, cExp), "=IFERROR(" & expF & ls & "0)"

        '扣甲/扣血（保持旧：扣甲=甲伤；扣血=期望肉伤）
        SetCellFormulaCompat ws.Cells(r, cAR), "=IFERROR(MAX(0" & ls & prevA & "-" & ad & ")" & ls & "0)"
        SetCellFormulaCompat ws.Cells(r, cHP), "=IFERROR(MAX(0" & ls & prevH & "-(" & expF & "))" & ls & "0)"
    Next i
End Sub

Private Function Nz(ByVal v As Variant, ByVal dflt As Variant) As Variant
    If IsError(v) Then Nz = dflt: Exit Function
    If IsEmpty(v) Or IsNull(v) Then Nz = dflt: Exit Function
    If VarType(v) = vbString And Trim$(v) = "" Then Nz = dflt: Exit Function
    Nz = v
End Function

'=========================================================
' 定位 O/P/Q 分层表：表头包含
'  O: 差值下限(闭)   P: 差值上限(开)   Q: 对肉伤的影响
'=========================================================
Private Function DetectTierTable_OPQ(ByVal ws As Worksheet, ByRef hdrRow As Long, ByRef firstRow As Long, ByRef lastRow As Long) As Boolean
    DetectTierTable_OPQ = False
    hdrRow = 0: firstRow = 0: lastRow = 0

    Dim r As Long
    For r = 1 To 200
        Dim o As String, p As String, q As String
        o = Trim$(CStr(ws.Cells(r, "O").Value2))
        p = Trim$(CStr(ws.Cells(r, "P").Value2))
        q = Trim$(CStr(ws.Cells(r, "Q").Value2))

        If InStr(1, o, "差值下限", vbTextCompare) > 0 _
           And InStr(1, p, "差值上限", vbTextCompare) > 0 _
           And InStr(1, q, "对肉伤", vbTextCompare) > 0 Then
            hdrRow = r
            Exit For
        End If
    Next r

    If hdrRow = 0 Then Exit Function

    firstRow = hdrRow + 1
    lastRow = firstRow - 1

    For r = firstRow To firstRow + 200
        If Not IsNumeric(ws.Cells(r, "O").Value2) Then Exit For
        If Not IsNumeric(ws.Cells(r, "P").Value2) Then Exit For
        lastRow = r
    Next r

    If lastRow < firstRow Then Exit Function

    DetectTierTable_OPQ = True
End Function

Private Function LoadTierArrays(ByVal ws As Worksheet, ByVal firstRow As Long, ByVal lastRow As Long, _
                               ByRef tLow() As Double, ByRef tHigh() As Double, ByRef tRate() As Double, ByRef tCnt As Long) As Boolean
    LoadTierArrays = False
    tCnt = 0

    Dim r As Long, n As Long
    n = lastRow - firstRow + 1
    ReDim tLow(1 To n)
    ReDim tHigh(1 To n)
    ReDim tRate(1 To n)

    For r = firstRow To lastRow
        tCnt = tCnt + 1
        tLow(tCnt) = CDbl(ws.Cells(r, "O").Value2)
        tHigh(tCnt) = CDbl(ws.Cells(r, "P").Value2)

        Dim v As Variant: v = ws.Cells(r, "Q").Value2
        'Q 允许 50% 或 0.5
        If VarType(v) = vbString And InStr(1, v, "%") > 0 Then
            tRate(tCnt) = CDbl(Replace(v, "%", "")) / 100#
        Else
            tRate(tCnt) = CDbl(v)
            If tRate(tCnt) > 1.5 Then tRate(tCnt) = tRate(tCnt) / 100# '保险：有人填 50 而不是 0.5
        End If

        If tHigh(tCnt) <= tLow(tCnt) Then Exit Function
    Next r

    LoadTierArrays = True
End Function

'=========================================================
' 定位怪物表：扫描表头行，找到列
'（怪物/等级/气血/护甲等级/肉伤/穿透/甲伤）
'=========================================================
Private Function DetectMonsterTable(ByVal ws As Worksheet, ByRef row1 As Long, ByRef rowN As Long) As Boolean
    DetectMonsterTable = False
    row1 = 0: rowN = 0

    Dim r As Long
    For r = 1 To 50
        If Trim$(CStr(ws.Cells(r, 1).Value2)) = "怪物" Then
            If InStr(1, CStr(ws.Cells(r, 2).Value2), "等级", vbTextCompare) > 0 Then
                row1 = r + 1
                Exit For
            End If
        End If
    Next r
    If row1 = 0 Then Exit Function

    Dim rr As Long
    rr = row1
    Do While rr < row1 + 200
        If Trim$(CStr(ws.Cells(rr, 1).Value2)) = "" Then Exit Do
        rr = rr + 1
    Loop
    rowN = rr - 1

    DetectMonsterTable = (rowN >= row1)
End Function

'=========================================================
' pb 系数：delta=pen-armorLv*10，在 O/P/Q 区间中找 (low<=delta<high)
'=========================================================
Private Function PbCoeff(ByVal delta As Double, ByRef tLow() As Double, ByRef tHigh() As Double, ByRef tRate() As Double, ByVal tCnt As Long) As Double
    Dim i As Long
    For i = 1 To tCnt
        If delta >= tLow(i) And delta < tHigh(i) Then
            PbCoeff = tRate(i)
            Exit Function
        End If
    Next i
    PbCoeff = 1# '兜底
End Function

'=========================================================
' 逐步块：怪打人（新模型）
' - 初始护甲耐久 = armorDur(armorLv)
' - defPerf / 穿透% 不改你旧规则：这里直接用你原先那套公式（写在输出表里）
' - 肉伤改为：穿透肉伤 = CEILING(pb*flesh,1) 且至少 1；未穿透肉伤=CEILING(0.04*flesh,1) 且至少 1
' - 护甲剩余 = MAX(0, 上一行护甲剩余 - 甲伤)
' - 血量剩余 = MAX(0, 上一行血量剩余 - 期望肉伤)
'=========================================================
Private Function WriteBlock_MonsterHitsPerson_New(ByVal wsO As Worksheet, ByVal startRow As Long, _
                                                 ByVal wsC As Worksheet, ByVal monRow1 As Long, ByVal monRowN As Long, _
                                                 ByVal mLv As Long, ByRef armorDur() As Double, _
                                                 ByRef tLow() As Double, ByRef tHigh() As Double, ByRef tRate() As Double, ByVal tCnt As Long) As Long
    Dim r As Long: r = startRow

    WriteTitle wsO, r, "怪打人（新模型）- 怪物等级=" & mLv: r = r + 1
    wsO.Cells(r, 1).Value2 = "人物护甲等级"
    wsO.Cells(r, 2).Value2 = "攻击次数"
    wsO.Cells(r, 3).Value2 = "防御性能"
    wsO.Cells(r, 4).Value2 = "穿透%"
    wsO.Cells(r, 5).Value2 = "期望肉伤"
    wsO.Cells(r, 6).Value2 = "护甲剩余"
    wsO.Cells(r, 7).Value2 = "血量剩余"
    wsO.Range(wsO.Cells(r, 1), wsO.Cells(r, 7)).Font.Bold = True
    r = r + 1

    '从怪物表里找到该等级那一行（默认：怪物表按等级 1..5 每行一个）
    Dim srcR As Long: srcR = monRow1 + (mLv - 1)
    If srcR > monRowN Then
        wsO.Cells(r, 1).Value2 = "（未找到怪物等级行）"
        WriteBlock_MonsterHitsPerson_New = r
        Exit Function
    End If

    Dim hp0 As Double, armorLv As Long, flesh As Double, pen As Double, ad As Double
    hp0 = CDbl(Nz(wsC.Cells(srcR, 4).Value2, 0))         'D 气血
    armorLv = CLng(Nz(wsC.Cells(srcR, 5).Value2, 0))     'E 护甲等级（怪等级行里的护甲等级只是怪本身；怪打人这里用“人物护甲等级”循环，不用它）
    flesh = CDbl(Nz(wsC.Cells(srcR, 7).Value2, 0))       'G 肉伤
    pen = CDbl(Nz(wsC.Cells(srcR, 8).Value2, 0))         'H 穿透
    ad = CDbl(Nz(wsC.Cells(srcR, 9).Value2, 0))          'I 甲伤

    '每个“人物护甲等级”做一段，最多写 60 次（你自己表里最多也就几十次）
    Dim aLv As Long, k As Long
    For aLv = 1 To 5
        Dim a0 As Double: a0 = armorDur(aLv)

        '段标题行
        wsO.Cells(r, 1).Value2 = aLv & "级"
        wsO.Cells(r, 1).Font.Bold = True
        r = r + 1

        '写 1..60 次（让 Excel 算，最后你肉眼看/也可用于回填统计）
        For k = 1 To 60
            Dim rr As Long: rr = r + (k - 1)

            wsO.Cells(rr, 1).Value2 = aLv
            wsO.Cells(rr, 2).Value2 = k

            '上一行引用（第1次用常量）
            Dim prevA As String, prevH As String
            If k = 1 Then
                prevA = CStr(a0)
                prevH = CStr(hp0)
            Else
                prevA = wsO.Cells(rr - 1, 6).Address(False, False)
                prevH = wsO.Cells(rr - 1, 7).Address(False, False)
            End If

            'defPerf（完全沿用你之前那条）
            wsO.Cells(rr, 3).Formula = "=IFERROR((121-5000/(45+((" & prevA & ")/225*100)*2))*(" & aLv & "*10)/100,0)"

            'pProb（沿用你之前那套结构；这里用“防御性能”单元格引用）
            Dim defCell As String: defCell = wsO.Cells(rr, 3).Address(False, False)
            wsO.Cells(rr, 4).Formula = "=IFERROR(IF(" & defCell & "<=" & pen & ",1," & _
                                       "IF(" & defCell & "-" & pen & "<15,MAX(0,(-0.9*(" & defCell & "-" & pen & ")+100)/100)," & _
                                       "MAX(0,(0.4*POWER((" & defCell & "-" & pen & "-15),2))/100))),0)"

            'pb 系数（用 VBA 先算出来写死到公式里，避免 MATCH 排序问题）
            Dim delta As Double: delta = pen - aLv * 10#
            Dim pb As Double: pb = PbCoeff(delta, tLow, tHigh, tRate, tCnt)

            '穿透肉伤 / 未穿透肉伤（至少 1）
            Dim penF As String, npF As String
            penF = "MAX(1,CEILING(" & pb & "*" & flesh & ",1))"
            npF = "MAX(1,CEILING(0.04*" & flesh & ",1))"

            '期望肉伤
            wsO.Cells(rr, 5).Formula = "=IFERROR(IF(" & prevA & "=0," & flesh & "," & _
                                       wsO.Cells(rr, 4).Address(False, False) & "*" & penF & "+(1-" & _
                                       wsO.Cells(rr, 4).Address(False, False) & ")*" & npF & "),0)"

            '护甲剩余（只扣甲伤：不改你原始规则）
            wsO.Cells(rr, 6).Formula = "=IFERROR(MAX(0," & prevA & "-" & ad & "),0)"

            '血量剩余
            wsO.Cells(rr, 7).Formula = "=IFERROR(MAX(0," & prevH & "-" & wsO.Cells(rr, 5).Address(False, False) & "),0)"
        Next k

        r = r + 60 + 1
    Next aLv

    WriteBlock_MonsterHitsPerson_New = r
End Function

'=========================================================
' 回填：怪打人汇总（写回 16-22）
' 这里我做成“只回填你要的期望次数”（按血量剩余<=0 的首次次数）
' 你如果 16-22 的具体格子位置固定，我需要你表里那块的具体坐标；
' 所以这里先按“在 16-22 中找到包含 ‘怪打人’ 的表头块”做自动定位。
'=========================================================
Private Sub WriteSummary_MonsterHitsPerson(ByVal wsC As Worksheet, ByVal monRow1 As Long, ByVal monRowN As Long, _
                                          ByRef armorDur() As Double, ByRef tLow() As Double, ByRef tHigh() As Double, ByRef tRate() As Double, ByVal tCnt As Long)
    '你目前对 16-22 的布局没有给出“明确列坐标规则”（哪些列对应怪打人哪一块）
    '为了不继续“自由发挥”，我这里不瞎写列。
    '——你把你 16-22 那块“怪打人汇总”的左上角单元格坐标告诉我（例如 A16 / B16 这种），
    '我再把这个函数补成“精准回填”。
End Sub

'=========================================================
' 回填：人打怪汇总（写回 16-22）
' 同上：缺少你 16-22 的“汇总表格明确定位规则”，先不硬写，避免写错列。
'=========================================================
Private Sub WriteSummary_PersonHitsMonster(ByVal wsC As Worksheet, ByVal monRow1 As Long, ByVal monRowN As Long, _
                                          ByVal gunMap As Object, ByVal bulletMap As Object, _
                                          ByRef tLow() As Double, ByRef tHigh() As Double, ByRef tRate() As Double, ByVal tCnt As Long)
    '同理：需要你告诉我 16-22 里“人打怪汇总”的目标区域左上角坐标；
    '否则我只能“猜”列结构，然后又会变成你说的“自由发挥写错”。
End Sub

'=========================================================
' 读取枪表：人物枪支属性，表头行需包含：枪名 / 穿透值 / 甲伤 / 肉伤 / 子弹型号
' 输出到 gunMap(gunName) = Array(pen, ad, flesh, bulletId)
'=========================================================
Private Function LoadGunTable(ByVal ws As Worksheet, ByVal gunMap As Object) As Boolean
    LoadGunTable = False
    gunMap.RemoveAll

    Dim ur As Range: Set ur = ws.UsedRange
    Dim r As Long, c As Long

    Dim hdrR As Long: hdrR = 0
    Dim cGun As Long, cPen As Long, cAD As Long, cF As Long, cB As Long
    cGun = 0: cPen = 0: cAD = 0: cF = 0: cB = 0

    For r = 1 To ur.Rows.Count
        For c = 1 To ur.Columns.Count
            Dim s As String: s = Trim$(CStr(ur.Cells(r, c).Value2))
            If s = "枪名" Then cGun = ur.Column + c - 1
            If s = "穿透值" Then cPen = ur.Column + c - 1
            If s = "甲伤" Then cAD = ur.Column + c - 1
            If s = "肉伤" Then cF = ur.Column + c - 1
            If s = "子弹型号" Then cB = ur.Column + c - 1
        Next c
        If cGun > 0 And cPen > 0 And cAD > 0 And cF > 0 And cB > 0 Then
            hdrR = ur.Row + r - 1
            Exit For
        End If
        cGun = 0: cPen = 0: cAD = 0: cF = 0: cB = 0
    Next r
    If hdrR = 0 Then Exit Function

    Dim rr As Long: rr = hdrR + 1
    Do While rr <= ws.Rows.Count
        Dim gn As String: gn = Trim$(CStr(ws.Cells(rr, cGun).Value2))
        If gn = "" Then Exit Do

        gunMap(gn) = Array( _
            CDbl(Nz(ws.Cells(rr, cPen).Value2, 0)), _
            CDbl(Nz(ws.Cells(rr, cAD).Value2, 0)), _
            CDbl(Nz(ws.Cells(rr, cF).Value2, 0)), _
            Trim$(CStr(ws.Cells(rr, cB).Value2)) _
        )
        rr = rr + 1
    Loop

    LoadGunTable = (gunMap.Count > 0)
End Function

'=========================================================
' 读取子弹表：人物枪支属性，表头行需包含：
' 子弹型号 / 子弹等级 / 穿透值 / 甲伤 / 肉伤
' 输出到 bulletMap(key=bulletId & "|" & lvl)=Array(pen,ad,flesh)
'=========================================================
Private Function DetectGunTable(ByVal ws As Worksheet, ByRef gunTable As Range, ByRef gunCols As Object) As Boolean
    Dim need As Variant: need = Array("枪名", "穿透值", "甲伤", "肉伤", "子弹型号")
    Dim headerRow As Long, cols As Object
    If Not FindHeader(ws, need, headerRow, cols) Then DetectGunTable = False: Exit Function

    Dim colName As Long: colName = cols("枪名")
    Dim colLast As Long: colLast = cols("子弹型号")

    Dim lastRow As Long: lastRow = headerRow + 1
    Do While lastRow <= ws.Rows.Count And Trim$(CStr(ws.Cells(lastRow, colName).Value)) <> "": lastRow = lastRow + 1: Loop
    lastRow = lastRow - 1
    If lastRow <= headerRow Then DetectGunTable = False: Exit Function

    Set gunTable = ws.Range(ws.Cells(headerRow, colName), ws.Cells(lastRow, colLast))
    Set gunCols = cols
    DetectGunTable = True
End Function

Private Function DetectBulletTable(ByVal ws As Worksheet, ByRef bulletTable As Range, ByRef bulletCols As Object) As Boolean
    Dim need As Variant: need = Array("子弹型号", "子弹等级", "穿透值", "甲伤", "肉伤")
    Dim headerRow As Long, cols As Object
    If Not FindHeader(ws, need, headerRow, cols) Then DetectBulletTable = False: Exit Function

    Dim colType As Long: colType = cols("子弹型号")
    Dim colLast As Long: colLast = cols("肉伤")

    Dim lastRow As Long: lastRow = headerRow + 1
    Do While lastRow <= ws.Rows.Count And Trim$(CStr(ws.Cells(lastRow, colType).Value)) <> "": lastRow = lastRow + 1: Loop
    lastRow = lastRow - 1
    If lastRow <= headerRow Then DetectBulletTable = False: Exit Function

    Dim hdrR As Long: hdrR = 0
    Dim cId As Long, cLv As Long, cPen As Long, cAD As Long, cF As Long
    cId = 0: cLv = 0: cPen = 0: cAD = 0: cF = 0

    For r = 1 To ur.Rows.Count
        For c = 1 To ur.Columns.Count
            Dim s As String: s = Trim$(CStr(ur.Cells(r, c).Value2))
            If s = "子弹型号" Then cId = ur.Column + c - 1
            If s = "子弹等级" Then cLv = ur.Column + c - 1
            If s = "穿透值" Then cPen = ur.Column + c - 1
            If s = "甲伤" Then cAD = ur.Column + c - 1
            If s = "肉伤" Then cF = ur.Column + c - 1
        Next c
        If cId > 0 And cLv > 0 And cPen > 0 And cAD > 0 And cF > 0 Then
            hdrR = ur.Row + r - 1
            Exit For
        End If
        cId = 0: cLv = 0: cPen = 0: cAD = 0: cF = 0
    Next r
    If hdrR = 0 Then Exit Function

    Dim rr As Long: rr = hdrR + 1
    Do While rr <= ws.Rows.Count
        Dim bid As String: bid = Trim$(CStr(ws.Cells(rr, cId).Value2))
        If bid = "" Then Exit Do

        Dim lv As Long: lv = CLng(Nz(ws.Cells(rr, cLv).Value2, 0))
        Dim key As String: key = bid & "|" & lv

        bulletMap(key) = Array( _
            CDbl(Nz(ws.Cells(rr, cPen).Value2, 0)), _
            CDbl(Nz(ws.Cells(rr, cAD).Value2, 0)), _
            CDbl(Nz(ws.Cells(rr, cF).Value2, 0)) _
        )
        rr = rr + 1
    Loop

    LoadBulletTable = (bulletMap.Count > 0)
End Function



Private Sub SetCellFormulaCompat(ByVal tgt As Range, ByVal fx As String)
    On Error GoTo TryFormula
    tgt.Formula2 = fx
    Exit Sub

TryFormula:
    Err.Clear
    On Error GoTo TryFormulaArray
    tgt.Formula = fx
    Exit Sub

TryFormulaArray:
    Err.Clear
    On Error GoTo FailHard
    tgt.FormulaArray = fx
    Exit Sub

FailHard:
    Err.Raise vbObjectError + 513, "SetCellFormulaCompat", "公式写入失败: " & Err.Description
End Sub


'=========================================================
' 工具
'=========================================================
Private Function ParseLv(ByVal s As String) As Long
    Dim t As String: t = Replace(Trim$(s), "级", "")
    If IsNumeric(t) Then ParseLv = CLng(t) Else ParseLv = 0
End Function


